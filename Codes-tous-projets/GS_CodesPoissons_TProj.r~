# Ginger/Soproner
# Code pour calcul des densités et indices de biodiversité pour les poissons
# Time-stamp: <2015-01-19 14:36:52 Laura>

# Fichiers des données de comptage = dpoissons, produit dans prep.analyse()
########################################################
########################################################
# Densité
POIS.dens.gnrl <- function(fspat="St", incl.zero=FALSE,
                                par.espece=TRUE, variable.esp) { # formerly BD.by.sp()

  ################################
  departFunk() # message de depart
  on.exit(EM())
  ################################

  # Calcul densite/biomasse par espece/transect/campagne
  # unité de base pour le calcul est "St" par défaut
  ff <- unique(c("Campagne",fspat,"St","T","Code_SP")) # variables d'aggrégation grande -> petite
  if(!missing(variable.esp)) {
    ff <- c(ff[-length(ff)], variable.esp, "Code_SP")
    if(!(variable.esp %in% c("GTlabel","moblabel","Peche","Cible"))) {
      stop("La valeur de variable.esp doit être: GTlabel, moblable, Peche ou Cible") }
    }

  ds.calc <- dpoissons # transfert à l'objet ds.calc
  if(!incl.zero) ds.calc <- ds.calc[ds.calc$N>0,]
  LT <- ds.calc$Long.Transct[1]
  if(diff(range(ds.calc$Long.Transct))!=0) print("Attention plus d'une longueur de transect par projet")

  # calcul de la densité/biomasse sur unité spatiale aggrégée et par espèce
  # on dérive la distance moyenne pondérée
  # ... c-a-d la distance moyenne de chaque observation pondérée
  # par le nombre d'individus observés, i.e. sum(dm*N_i)/sum(N_i)
  ds.calc$dm.int <- ds.calc$N * (0.5*(ds.calc$D1+ds.calc$D2)+0.5)
  ds.df <- aggregate(ds.calc[,c("dm.int","N")],as.list(ds.calc[,ff]),sum)
  ds.df$dm <- ds.df$dm.int/ds.df$N # valeur finale, moyenne pondérée
  ds.df$dens <- ds.df$N/(2*ds.df$dm*LT) # Densité

  # Calcul de la biomasse et de la taille moyenne
  ds.calc$bio.int <- ds.calc$N * ds.calc$a * ds.calc$L^ds.calc$b
  ds.calc$TM <- ds.calc$N*ds.calc$L # numérateur taille moyenne
  num.bio <- aggregate(ds.calc[,c("bio.int","TM")], as.list(ds.calc[,ff]), sum)
  ds.df$biomasse <- num.bio$bio.int/(2*ds.df$dm*LT) # Biomasse

  # Taille moyenne pondérée sur le nombre d'individus
  ds.df$taille.moy <- num.bio$TM/ds.df$N

  # Biomasse/Dens -> zero si allN=0 mais laisser la taille.moy a NA
  # pour que les moyennes de tailles soient calculees sur les individus
  # observés seulements
  ds.df[ds.df$N==0,c("dens","biomasse")] <- 0

  # Calcul des biomasses/densités moyennes par unité spatiale 'fspat'
  # (par St par défaut)
  ff <- ff[1:which(ff==fspat[length(fspat)])]
  if(!missing(variable.esp)) ff <- c(ff,variable.esp)
  if(par.espece) ff <- c(ff,"Code_SP")
  pois.metr <- c("dens","N","biomasse","taille.moy")
  t1.moy <- aggregate(ds.df[,pois.metr],
                      as.list(ds.df[,ff]), tot.mean.sd, na.rm=TRUE)
  # ... reconversion à data.frame
  t2 <- do.call("data.frame", t1.moy[,pois.metr])
  t1.moy <- data.frame(t1.moy[,1:length(pois.metr)], t2)

  t1.moy <- t1.moy[,!(names(t1.moy)=="taille.moy.Tot")] # ôte la somme de la taille moyenne
  # Richesse spécifique sur l'unité spatiale par défaut (St)
  ff.RS <- ff[!(ff == "Code_SP")]
  print(ff.RS)
  t1.RS <- aggregate(list(RS=ds.df$Code_SP), as.list(ds.df[,ff.RS]), count)

  start.timer()
  t2 <- merge(t1.moy, t1.RS)
  stop.timer()
  # ordonner par campagne/sites
#  ds.df <- ds.df[order(ds.df$St, ds.df$Campagne),]

  # rajouter colonnes infos additionelles
#  facteurs <- c("An","St","Zone.Impact","Geomorpho","Code_SP",
#                "Peche","Groupe.Trophique","Groupe.Mobil","Cible")
#  ttble <- unique(ds.calc[,c("Campagne",facteurs)])
#  BDtable.i <- merge(ds.df,ttble,c("Campagne","St","Code_SP"))
#  BDtable <- merge(BDtable.i,bioeco.all[,c("Code_SP","Famille","Genre","G_Sp","fmlabel")],
#                   by="Code_SP")

 # return(BDtable)

  return(t2)
}

########################################################
########################################################
## Indices de biodiversité
